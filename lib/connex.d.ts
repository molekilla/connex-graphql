export declare const connexSchema = "\nscalar JSON\nscalar Bool\nscalar String\n# Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal.\nscalar Bytes32\n# Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal.\nscalar Address\n# Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.\n# An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.\nscalar Bytes\n# BigInt is a large integer. Input is accepted as either a JSON number or as a string.\n# Strings may be either decimal or 0x-prefixed hexadecimal. Output values are all\n# 0x-prefixed hexadecimal.\nscalar BigInt\n# Long is a 64 bit unsigned integer.\nscalar Long\n\nschema {\n    query: Query\n    mutation: Mutation\n}\n\n# Account is an Ethereum account at a particular block.\ntype Account {\n    # Address is the address owning the account.\n    address: Address!\n    # Balance is the balance of the account, in wei.\n    balance: BigInt!\n    energy: Bytes32\n    hasCode: Bool\n    # Code contains the smart contract code for this account, if the account\n    # is a (non-self-destructed) contract.\n    code: Bytes!\n    # Storage provides access to the storage of a contract account, indexed\n    # by its 32 byte slot identifier.\n    # storage(slot: Bytes32!): Bytes32!\n}\n\ntype Meta {\n    blockID: Bytes32\n    blockNumber: Long\n    blockTimestamp: Long\n    txID: Bytes32\n    txOrigin: Bytes32\n}\n\n# Log is an Ethereum event log.\ntype Log {\n    address: Bytes32\n    # Topics is a list of 0-4 indexed topics for the log.\n    topics: [Bytes32!]\n    # Data is unindexed data for this log.\n    data: Bytes \n    meta: Meta\n    decoded: JSON\n    timestamp: Long\n    txDate: String\n    logName: String\n\n    sender: Bytes32\n    recipient: Bytes32\n    amount: Bytes32\n}\n\n# Transaction is an Ethereum transaction.\ntype Transaction {\n    # Hash is the hash of this transaction.\n    hash: Bytes32!\n    # Nonce is the nonce of the account this transaction was generated with.\n    nonce: Long!\n    # Index is the index of this transaction in the parent block. This will\n    # be null if the transaction has not yet been mined.\n    index: Int\n    # From is the account that sent this transaction - this will always be\n    # an externally owned account.\n    from(block: Long): Account!\n    # To is the account the transaction was sent to. This is null for\n    # contract-creating transactions.\n    to(block: Long): Account\n    # Value is the value, in wei, sent along with this transaction.\n    value: BigInt!\n    # GasPrice is the price offered to miners for gas, in wei per unit.\n    gasPrice: BigInt!\n    # Gas is the maximum amount of gas this transaction can consume.\n    gas: Long!\n    # InputData is the data supplied to the target of the transaction.\n    inputData: Bytes!\n    # Block is the block this transaction was mined in. This will be null if\n    # the transaction has not yet been mined.\n    block: Block\n\n    # Status is the return status of the transaction. This will be 1 if the\n    # transaction succeeded, or 0 if it failed (due to a revert, or due to\n    # running out of gas). If the transaction has not yet been mined, this\n    # field will be null.\n    status: Long\n    # GasUsed is the amount of gas that was used processing this transaction.\n    # If the transaction has not yet been mined, this field will be null.\n    gasUsed: Long\n    # CumulativeGasUsed is the total gas used in the block up to and including\n    # this transaction. If the transaction has not yet been mined, this field\n    # will be null.\n    cumulativeGasUsed: Long\n    # CreatedContract is the account that was created by a contract creation\n    # transaction. If the transaction was not a contract creation transaction,\n    # or it has not yet been mined, this field will be null.\n    createdContract(block: Long): Account\n    # Logs is a list of log entries emitted by this transaction. If the\n    # transaction has not yet been mined, this field will be null.\n    logs: [Log!]\n}\n\ninput Range {\n    from: Long\n    to: Long\n}\n\ninput Criteria {\n    # Event\n    address: Bytes32\n    topic0: String\n    topic1: Bytes32\n    topic2: Bytes32\n    topic3: Bytes32\n    topic4: Bytes32\n\n    # Transfer\n    txOrigin: Bytes32\n    sender: Bytes32\n    recipient: Bytes32\n}\n\n# FilterCriteria encapsulates log filter criteria for searching log entries.\ninput FilterCriteria {\n    kind: String   # event | transfer\n    order: String  # asc | desc\n    range: Range\n    limit: Long\n    offset: Long\n    criterias: [Criteria]\n\n  # Examples:\n  #  - [] or nil          matches any topic list\n  #  - [[A]]              matches topic A in first position\n  #  - [[], [B]]          matches any topic in first position, B in second position\n  #  - [[A], [B]]         matches topic A in first position, B in second position\n  #  - [[A, B]], [C, D]]  matches topic (A OR B) in first position, (C OR D) in second position\n    # topics: [[Bytes32!]!]\n}\n\ninput ContractFilterCriteria {\n    indexed: JSON\n    order: String\n    range: Range\n    limit: Long\n    offset: Long\n    criterias: [Criteria]\n\n  # Examples:\n  #  - [] or nil          matches any topic list\n  #  - [[A]]              matches topic A in first position\n  #  - [[], [B]]          matches any topic in first position, B in second position\n  #  - [[A], [B]]         matches topic A in first position, B in second position\n  #  - [[A, B]], [C, D]]  matches topic (A OR B) in first position, (C OR D) in second position\n    # topics: [[Bytes32!]!]\n}\n\ntype Head {\n    id: Bytes32\n    number: Long\n    timestamp: Long\n    parentID: Bytes32\n}\n\ntype Status {\n    progress: Long\n    head: Head\n}\n\ntype Block {\n    id: Bytes32\n    number: Long\n    parentID: Bytes32\n    timestamp: Long\n    gasLimit: Long\n    beneficiary: Bytes32\n    gasUsed: Long\n    totalScore: Long\n    txRoot: Bytes32\n    stateRoot: Bytes32\n    signer: String\n    transactions: [Bytes32]\n    isTrunk: Bool\n}\n\ntype Query {\n    # Block fetches an Ethereum block by number or by hash. If neither is\n    # supplied, the most recent known block is returned.\n    # block(number: Long, hash: Bytes32): Block\n    # Blocks returns all the blocks between two numbers, inclusive. If\n    # to is not supplied, it defaults to the most recent known block.\n    # blocks(from: Long!, to: Long): [Block!]!\n    # Pending returns the current pending state.\n    # pending: Pending!\n    # Transaction returns a transaction specified by its hash.\n    # transaction(hash: Bytes32!): Transaction\n    # Logs returns log entries matching the provided filter.\n    # logs(filter: FilterCriteria!): [Log!]!\n    filter(filter:  FilterCriteria!): [Log!]!\n    contractFilter(address: Bytes32!,abiSignatures: [String!]!,\n    filter:  ContractFilterCriteria!): [Log!]!\n    status: Status\n    genesis: Block\n    connexVersion: String\n    account(address: Address): Account!\n}\n\ntype Mutation {\n    # SendRawTransaction sends an RLP-encoded transaction to the network.\n    sendRawTransaction(data: Bytes!): Bytes32!\n}\n";
